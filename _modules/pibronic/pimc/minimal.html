
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pibronic.pimc.minimal &#8212; Pibronic 0.1.2 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pibronic.pimc.minimal</h1><div class="highlight"><pre>
<span></span><span class="c1"># minimal.py</span>

<span class="c1"># system imports</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># third party imports</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">newaxis</span> <span class="k">as</span> <span class="n">NEW</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">float64</span> <span class="k">as</span> <span class="n">F64</span>

<span class="c1"># local imports</span>
<span class="kn">from</span> <span class="nn">..log_conf</span> <span class="k">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">..constants</span> <span class="k">import</span> <span class="n">hbar</span>
<span class="kn">from</span> <span class="nn">..data</span> <span class="k">import</span> <span class="n">file_structure</span>
<span class="kn">from</span> <span class="nn">..data</span> <span class="k">import</span> <span class="n">file_name</span>  <span class="c1"># do we need this?</span>
<span class="kn">from</span> <span class="nn">..data</span> <span class="k">import</span> <span class="n">vibronic_model_io</span> <span class="k">as</span> <span class="n">vIO</span>
<span class="kn">from</span> <span class="nn">..server</span> <span class="k">import</span> <span class="n">job_boss</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">For future thought:</span>
<span class="sd">see - https://stackoverflow.com/questions/5836335/consistently-create-same-random-numpy-array/5837352#5837352</span>
<span class="sd">and - https://stackoverflow.com/questions/32172054/how-can-i-retrieve-the-current-seed-of-numpys-random-number-generator?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</span>

<span class="sd">Will have to think carefully about recording the random inputs that are sampled in a robust and cohesive manner</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">float_tolerance</span> <span class="o">=</span> <span class="mf">1e-23</span>

<span class="sd">&quot;&quot;&quot; TODO - eventually this should be replaced so that each time a sample is drawn</span>
<span class="sd">a new seed is generated and stored in the results file indexed with the fraction it generated</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span><span class="c1"># random</span>
<span class="c1"># np.random.seed(232942) # pick our seed</span>


<div class="viewcode-block" id="TemperatureDependentClass"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.TemperatureDependentClass">[docs]</a><span class="k">class</span> <span class="nc">TemperatureDependentClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;store temperture dependent constants here&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>

        <span class="c1"># construct the coth and csch tensors</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;AN&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cothAN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">hbar</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">hbar</span><span class="o">*</span><span class="n">tau</span><span class="o">*</span><span class="n">omega</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># construct different sized tensors for efficiency purposes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cothANP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cothAN</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cothAN</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cschANP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cothBANP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cothAN</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cothAN</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cschBANP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># this is the constant prefactor that doesn&#39;t depend on</span>
        <span class="c1"># sampled co-ordinates</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">model</span><span class="o">.</span><span class="n">energy</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="n">energy</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">delta_weight</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">prefactor</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPA&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omatrix_prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tau</span> <span class="o">*</span> <span class="n">prefactor</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cschAN</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPAN&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omatrix_prefactor</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">prefactor</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="c1"># note that there is no sqrt(1/2*pi) because it factors out of the numerator and denominator</span>

        <span class="c1"># cache for the Omatrix on each block loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPAA&#39;</span><span class="p">])</span>
        <span class="c1"># cache for the Omatrix scaling factor on each block loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omatrix_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BP&#39;</span><span class="p">])</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="ModelClass"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelClass">[docs]</a><span class="k">class</span> <span class="nc">ModelClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;information describing a quantum mechanical system&quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">quadratic</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">quartic</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="ModelClass.from_json_file"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelClass.from_json_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;constructor wrapper&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">target_file</span><span class="p">:</span>
            <span class="n">json_obj</span> <span class="o">=</span> <span class="n">target_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="ModelClass.load_model"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelClass.load_model">[docs]</a>    <span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="c1"># I think this fails if the list elements are multidimensional numpy arrays</span>
        <span class="c1"># carefully check this</span>
        <span class="c1"># lazy way of assuming that if one array is empty this is the first time</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span><span class="p">]):</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span><span class="p">,</span>
             <span class="p">)</span> <span class="o">=</span> <span class="n">vIO</span><span class="o">.</span><span class="n">load_model_from_JSON</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;number of modes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;number of surfaces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;energies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;frequencies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;linear couplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;quadratic couplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span>
            <span class="n">vIO</span><span class="o">.</span><span class="n">load_model_from_JSON</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># should we update the states and modes after loading the model?</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="ModelVibronic"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic">[docs]</a><span class="k">class</span> <span class="nc">ModelVibronic</span><span class="p">(</span><span class="n">ModelClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;stores information about the system of interest&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tau</span>

        <span class="c1"># model paramters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;AA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;NAA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;NNAA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>

        <span class="c1"># sampling parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;AN&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="ModelVibronic.compute_linear_displacement"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.compute_linear_displacement">[docs]</a>    <span class="k">def</span> <span class="nf">compute_linear_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute the energy shift equivalent to a linear displacement&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delta_weight</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">[:,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelVibronic.compute_weight_for_each_state"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.compute_weight_for_each_state">[docs]</a>    <span class="k">def</span> <span class="nf">compute_weight_for_each_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modified_energy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;these are the weights for the oscillators associated with each state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">modified_energy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">/=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="c1"># normalize the weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelVibronic.optimize_energy"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.optimize_energy">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; shift the energy to reduce the order of the raw partition function value &quot;&quot;&quot;</span>

        <span class="c1"># -- CURRENTLY DOES NOTHING -- #</span>
        <span class="c1"># So the problem here is that if you scale the energy you have to affect</span>
        <span class="c1"># the output because the initial values are just different</span>
        <span class="c1"># self.energyShift = np.nanmin(np.diagonal(self.energy)</span>
        <span class="c1">#                                    + self.delta_weight)</span>
        <span class="c1"># only shift the diagonal of the energy</span>
        <span class="c1"># for a in range(self.states):</span>
        <span class="c1">#     self.energy[a,a] -= self.energyShift</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelVibronic.initialize_TDP_object"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.initialize_TDP_object">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_TDP_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates the TemperatureDependentClass object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="n">TemperatureDependentClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelVibronic.finish_folding_in_terms"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.finish_folding_in_terms">[docs]</a>    <span class="k">def</span> <span class="nf">finish_folding_in_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; set the terms we &#39;folded in&#39; to zero &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
            <span class="c1"># we &#39;fold&#39; the linear term into the harmonic oscillator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">[:,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
            <span class="c1"># then we remove it from the calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">[:,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># zero energy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelVibronic.precompute"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronic.precompute">[docs]</a>    <span class="k">def</span> <span class="nf">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;precompute some constants&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_linear_displacement</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># duplicate the diagonal and then zero it for later use in the M matrix</span>
        <span class="n">energyDiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_energy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_weight_for_each_state</span><span class="p">(</span><span class="n">energyDiag</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_TDP_object</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finish_folding_in_terms</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="ModelVibronicPM"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronicPM">[docs]</a><span class="k">class</span> <span class="nc">ModelVibronicPM</span><span class="p">(</span><span class="n">ModelVibronic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plus minus version of ModelVibronic&quot;&quot;&quot;</span>
    <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">beta_plus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">beta_minus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tau_plus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tau_minus</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">delta_beta</span>
        <span class="k">return</span>

<div class="viewcode-block" id="ModelVibronicPM.initialize_TDP_object"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronicPM.initialize_TDP_object">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_TDP_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates the TemperatureDependentClass object&quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_TDP_object</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">const_plus</span> <span class="o">=</span> <span class="n">TemperatureDependentClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_plus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const_minus</span> <span class="o">=</span> <span class="n">TemperatureDependentClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_minus</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="c1"># precompute some constants</span>
<div class="viewcode-block" id="ModelVibronicPM.precompute"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelVibronicPM.precompute">[docs]</a>    <span class="k">def</span> <span class="nf">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># store extra constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_plus</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">beads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_minus</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">beads</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="ModelSampling"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling">[docs]</a><span class="k">class</span> <span class="nc">ModelSampling</span><span class="p">(</span><span class="n">ModelClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;stores information about the system of interest&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># copy the sizes of the parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">param_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size_list</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">beta</span>
        <span class="k">return</span>

<div class="viewcode-block" id="ModelSampling.load_model"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.load_model">[docs]</a>    <span class="k">def</span> <span class="nf">load_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filePath</span><span class="p">):</span>
        <span class="n">sameModes</span><span class="p">,</span> <span class="n">newStates</span> <span class="o">=</span> <span class="n">vIO</span><span class="o">.</span><span class="n">get_nmode_nsurf_from_sampling_model</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">filePath</span><span class="p">)</span>

        <span class="c1"># replace the vibronic models state size with rho&#39;s state size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">newStates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">sameModes</span>

        <span class="c1"># construct &#39;size&#39; tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">key</span><span class="p">])</span>

        <span class="c1"># model paramters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;NA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="c1"># in this case we might need to rethink the load_sample_from_JSON - here we provide quadratic when they are zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;NNA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>

        <span class="c1"># sampling parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;AN&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cc_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BNP&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>

        <span class="c1"># this brings up the good point that we might want to load a JSON file without providing the number of modes and surfaces</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;number of modes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;number of surfaces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;energies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;frequencies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;linear couplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;quadratic couplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span>
        <span class="n">vIO</span><span class="o">.</span><span class="n">load_sample_from_JSON</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.draw_sample"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.draw_sample">[docs]</a>    <span class="k">def</span> <span class="nf">draw_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates collective co-ordinates and stores them in self.cc_samples with dimensions BNP&quot;&quot;&quot;</span>
        <span class="c1"># collective co-ordinate samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cc_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                                    <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_means</span><span class="p">,</span>
                                    <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">standard_deviation</span><span class="p">[</span><span class="n">sample_view</span><span class="p">],</span>
                                    <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BNP&#39;</span><span class="p">],</span>
                                    <span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.compute_linear_displacement"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.compute_linear_displacement">[docs]</a>    <span class="k">def</span> <span class="nf">compute_linear_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute the energy shift equivalent to a linear displacement&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_weight</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="o">**</span><span class="mf">2.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[:,</span> <span class="n">NEW</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.compute_weight_for_each_state"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.compute_weight_for_each_state">[docs]</a>    <span class="k">def</span> <span class="nf">compute_weight_for_each_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;these are the weights for the oscillators associated with each state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">/=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="c1"># normalize the weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.optimize_energy"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.optimize_energy">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; shift the energy to reduce the order of the raw partition function value &quot;&quot;&quot;</span>

        <span class="c1"># -- CURRENTLY DOES NOTHING -- #</span>
        <span class="c1"># So the problem here is that if you scale the energy you have to affect</span>
        <span class="c1"># the output because the initial values are just different</span>
        <span class="c1"># self.energyShift = np.nanmin(np.diagonal(self.energy)</span>
        <span class="c1">#                                    + self.delta_weight)</span>
        <span class="c1"># only shift the diagonal of the energy</span>
        <span class="c1"># for a in range(self.states):</span>
        <span class="c1">#     self.energy[a,a] -= self.energyShift</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.initialize_TDP_object"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.initialize_TDP_object">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_TDP_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates the TemperatureDependentClass object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="n">TemperatureDependentClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.finish_folding_in_terms"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.finish_folding_in_terms">[docs]</a>    <span class="k">def</span> <span class="nf">finish_folding_in_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; set the terms we &#39;folded in&#39; to zero &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
            <span class="c1"># we &#39;fold&#39; the linear term into the harmonic oscillator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>
            <span class="c1"># then we remove it from the calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="ModelSampling.compute_sampling_constants"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.compute_sampling_constants">[docs]</a>    <span class="k">def</span> <span class="nf">compute_sampling_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

        <span class="c1"># generate random surfaces to draw samples from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">),</span>
                                               <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">],</span>
                                               <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_weight</span>
                                               <span class="p">)</span>

        <span class="c1"># the ordered offsets for multiple surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sources</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># calculate the means of each gaussian</span>

        <span class="c1"># inverse_covariance_matrix = 2. * coth_tensor[:, :, NEW] - sch_tensor[:, :, NEW] * O_eigvals[NEW, NEW, :]</span>
        <span class="c1"># inverse_covariance_matrix = 2. * self.const.coth[..., NEW] - self.const.csch[..., NEW] * data.circulant_eigvals[NEW, NEW, ...]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">cothANP</span>
                                   <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">cschANP</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">circulant_eigvals</span><span class="p">)</span>
        <span class="c1"># print(data.circulant_eigvects.T)</span>
        <span class="c1"># print(  &quot;Mode 1 &quot;,</span>
        <span class="c1">#         self.inverse_covariance[0,0,-1],</span>
        <span class="c1">#         np.sqrt(self.inverse_covariance[0,0,-1]),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,0,-1])),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,0,-1])) / np.sqrt(self.size[&#39;P&#39;][0]),</span>
        <span class="c1">#         6*(np.divide(1., np.sqrt(self.inverse_covariance[0,0,-1])) / np.sqrt(self.size[&#39;P&#39;][0])),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,0,-1])) / np.sqrt(self.size[&#39;P&#39;][0]/ 20),</span>
        <span class="c1">#         sep=&quot;\n&quot;,</span>
        <span class="c1">#     )</span>
        <span class="c1"># print(  &quot;Mode 2 &quot;,</span>
        <span class="c1">#         self.inverse_covariance[0,1,-1],</span>
        <span class="c1">#         np.sqrt(self.inverse_covariance[0,1,-1]),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,1,-1])),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,1,-1])) / np.sqrt(self.size[&#39;P&#39;][0]),</span>
        <span class="c1">#         6*(np.divide(1., np.sqrt(self.inverse_covariance[0,1,-1])) / np.sqrt(self.size[&#39;P&#39;][0])),</span>
        <span class="c1">#         np.divide(1., np.sqrt(self.inverse_covariance[0,1,-1])) / np.sqrt(self.size[&#39;P&#39;][0] / 20),</span>
        <span class="c1">#         sep=&quot;\n&quot;,</span>
        <span class="c1">#     )</span>
        <span class="c1"># self.self.inverse_covariance -= self.const.cschANP * data.circulant_eigvals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_sources</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BNP&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="c1"># precompute some constants</span>
<div class="viewcode-block" id="ModelSampling.precompute"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.ModelSampling.precompute">[docs]</a>    <span class="k">def</span> <span class="nf">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;precompute some constants&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_linear_displacement</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_energy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_weight_for_each_state</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_TDP_object</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finish_folding_in_terms</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_sampling_constants</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="BoxData"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData">[docs]</a><span class="k">class</span> <span class="nc">BoxData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;use this to pass execution paramters back and forth between methods&quot;&quot;&quot;</span>
    <span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># rho_states = 0</span>
    <span class="n">states</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">temperature</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">beads</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">id_data</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">id_rho</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># instance of the ModelVibronic class</span>
    <span class="c1"># holds all parameters associated with the model</span>
    <span class="n">vib</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path_vib_model</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># instance of the ModelSampling class</span>
    <span class="c1"># holds all parameters associated with the model</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path_rho_model</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># it would probably be better to shuffle this json passing black magic into job boss</span>
    <span class="c1"># perhaps job boss modifies the load_json function before calling it?</span>
    <span class="c1"># or maybe one of the optional paramters to load_json is the replacement symbol which by default is a colon?</span>

    <span class="c1"># we need to use SOME symbol(semicolon for example)</span>
    <span class="c1"># to allow the string to be treated as a SINGLE environment variable</span>
    <span class="c1"># slurm uses commas as the delimiters for its environment variable list</span>
    <span class="n">_COMMA_REPLACEMENT</span> <span class="o">=</span> <span class="s2">&quot;;&quot;</span>
    <span class="n">_SEPARATORS</span> <span class="o">=</span> <span class="p">(</span><span class="n">_COMMA_REPLACEMENT</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BoxData.from_FileStructure"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.from_FileStructure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_FileStructure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">FS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;constructor wrapper&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">id_data</span> <span class="o">=</span> <span class="n">FS</span><span class="o">.</span><span class="n">id_data</span>
        <span class="n">data</span><span class="o">.</span><span class="n">id_rho</span> <span class="o">=</span> <span class="n">FS</span><span class="o">.</span><span class="n">id_rho</span>

        <span class="n">data</span><span class="o">.</span><span class="n">path_vib_model</span> <span class="o">=</span> <span class="n">FS</span><span class="o">.</span><span class="n">path_vib_model</span>
        <span class="n">data</span><span class="o">.</span><span class="n">path_rho_model</span> <span class="o">=</span> <span class="n">FS</span><span class="o">.</span><span class="n">path_rho_model</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">vIO</span><span class="o">.</span><span class="n">get_nmode_nsurf_from_coupled_model</span><span class="p">(</span><span class="n">FS</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">data</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">N</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="BoxData.build"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.build">[docs]</a>    <span class="nd">@classmethod</span>  <span class="c1"># this feels unnecessary</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">id_data</span><span class="p">,</span> <span class="n">id_rho</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;constructor wrapper&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">id_data</span> <span class="o">=</span> <span class="n">id_data</span>
        <span class="n">data</span><span class="o">.</span><span class="n">id_rho</span> <span class="o">=</span> <span class="n">id_rho</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="BoxData.from_json_file"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.from_json_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_full</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;constructor wrapper&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_full</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">target_file</span><span class="p">:</span>
            <span class="n">json_obj</span> <span class="o">=</span> <span class="n">target_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_json_object</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="BoxData.from_json_object"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.from_json_object">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json_object</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;constructor wrapper&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">json_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

<div class="viewcode-block" id="BoxData.json_encode"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.json_encode">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">json_encode</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">json_obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">_SEPARATORS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json_obj</span></div>

<div class="viewcode-block" id="BoxData.encode_self"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.encode_self">[docs]</a>    <span class="k">def</span> <span class="nf">encode_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;encodes a json_obj with member values or given params&quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding data to JSON&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path_full</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;number_of_samples&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                <span class="s2">&quot;number_of_blocks&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">,</span>
                <span class="s2">&quot;number_of_states&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                <span class="s2">&quot;number_of_beads&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span><span class="p">,</span>
                <span class="s2">&quot;number_of_modes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">,</span>
                <span class="s2">&quot;temperature&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
                <span class="c1"># &quot;rho_states&quot;: self.rho_states,</span>
                <span class="s2">&quot;block_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_size</span><span class="p">,</span>
                <span class="s2">&quot;delta_beta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span><span class="p">,</span>
                <span class="s2">&quot;path_vib_model&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_vib_model</span><span class="p">,</span>
                <span class="s2">&quot;path_rho_model&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_rho_model</span><span class="p">,</span>
                <span class="s2">&quot;id_data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_data</span><span class="p">,</span>
                <span class="s2">&quot;id_rho&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_rho</span><span class="p">,</span>
                <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_encode</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="BoxData.load_json_object"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.load_json_object">[docs]</a>    <span class="k">def</span> <span class="nf">load_json_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">json_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;decodes the json_obj and sets member parameters&quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Decoding JSON obj&quot;</span><span class="p">)</span>
        <span class="n">json_obj</span> <span class="o">=</span> <span class="n">json_obj</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_COMMA_REPLACEMENT</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_obj</span><span class="p">)</span>

        <span class="c1"># replace with dictionary update?</span>
        <span class="c1"># def setVar(self, var):</span>
        <span class="c1"># for key, value in var.items():</span>
        <span class="c1"># setattr(self, key, value)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_blocks&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_states&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beads</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_beads&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_modes&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;temperature&quot;</span><span class="p">]</span>
        <span class="c1"># self.rho_states = params[&quot;rho_states&quot;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;block_size&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_vib_model</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;path_vib_model&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_rho_model</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;path_rho_model&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_data</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;id_data&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_rho</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;id_rho&quot;</span><span class="p">]</span>

        <span class="c1"># dumb hacks</span>
        <span class="k">if</span> <span class="s2">&quot;beta&quot;</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">boltzman</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
        <span class="c1"># dumb hacks</span>
        <span class="k">if</span> <span class="s2">&quot;tau&quot;</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxData.draw_sample"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.draw_sample">[docs]</a>    <span class="k">def</span> <span class="nf">draw_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws samples from the distribution rho -</span>
<span class="sd">        the rho object fills its cc_samples parameter with collective co-ordinates</span>
<span class="sd">        which will be transformed to bead dependent co-ordinates by self.transform_sampled_coordinates()&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxData.generate_random_R_values"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.generate_random_R_values">[docs]</a>    <span class="k">def</span> <span class="nf">generate_random_R_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">storage_array</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Randomly generates R values that have no relation to the distribution rho or g</span>
<span class="sd">        they only have the correct dimensions BANP and are shifted appropriately &quot;&quot;&quot;</span>
        <span class="c1"># generate sample points in dimensionless co-ordinates R</span>
        <span class="n">storage_array</span><span class="p">[</span><span class="n">sample_view</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BNP&#39;</span><span class="p">])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span><span class="p">,</span> <span class="n">storage_array</span><span class="p">[</span><span class="n">sample_view</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>

        <span class="c1"># we transform the dimensionless co-ordinates to surface dependent co-ordinates q = R - d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxData.transform_sampled_coordinates"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.transform_sampled_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">transform_sampled_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;transform from collective co-ordinates to bead dependent co-ordinates&quot;&quot;&quot;</span>
        <span class="c1"># self.qTensor = np.broadcast_to(np.einsum(&#39;ab,ijb-&gt;ija&#39;, self.circulant_eigvects, self.cc_samples), self.size[&#39;XANP&#39;])</span>
        <span class="c1"># self.qTensor = np.einsum(&#39;ab,ijb-&gt;ija&#39;, self.circulant_eigvects, self.cc_samples)[:, NEW, :, :]</span>
        <span class="c1"># self.qTensor = np.einsum(&#39;ab,ijb-&gt;ija&#39;, self.circulant_eigvects, self.cc_samples)[:, NEW, ...]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,ijb-&gt;ija&#39;</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">circulant_eigvects</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">cc_samples</span><span class="p">,</span>
                                    <span class="p">)[:,</span> <span class="n">NEW</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="c1"># remove sample dependent normal mode displacement (from sampling model)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">sample_shift</span><span class="p">[</span><span class="n">sample_view</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>
        <span class="c1"># add surface dependent normal mode displacement (from vibronic model)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxData.initialize_models"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.initialize_models">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span> <span class="o">=</span> <span class="n">ModelVibronic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_vib_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">ModelSampling</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># print(self.path_rho_model)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_rho_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxData.preprocess"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxData.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="c1"># for readability and clarity we use these letters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                           <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                           <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">,</span>
                           <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span><span class="p">,</span>
                           <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_size</span><span class="p">,</span> <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">size_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;BP&#39;</span><span class="p">,</span> <span class="s1">&#39;AN&#39;</span><span class="p">,</span> <span class="s1">&#39;NA&#39;</span><span class="p">,</span> <span class="s1">&#39;AA&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;BNP&#39;</span><span class="p">,</span> <span class="s1">&#39;BPA&#39;</span><span class="p">,</span> <span class="s1">&#39;BAA&#39;</span><span class="p">,</span> <span class="s1">&#39;XNP&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;NAA&#39;</span><span class="p">,</span> <span class="s1">&#39;NNA&#39;</span><span class="p">,</span> <span class="s1">&#39;ANP&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;BANP&#39;</span><span class="p">,</span> <span class="s1">&#39;BPAA&#39;</span><span class="p">,</span> <span class="s1">&#39;NNAA&#39;</span><span class="p">,</span> <span class="s1">&#39;BPAN&#39;</span><span class="p">,</span> <span class="p">]</span>

        <span class="c1"># construct &#39;size&#39; tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">key</span><span class="p">])</span>

        <span class="c1"># compute constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">boltzman</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span>

        <span class="c1"># where we store the transformed samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BANP&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>

        <span class="c1"># storage for the numerator calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPAA&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPA&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_eigvects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPAA&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BPAA&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BAA&#39;</span><span class="p">])</span>

        <span class="c1"># construct the circulant matrix</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;circulant matrix requires 3 or more beads&quot;</span><span class="c1"># hard check</span>
        <span class="n">defining_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beads</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">circulant_matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">circulant</span><span class="p">(</span><span class="n">defining_vector</span><span class="p">)</span>

        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circulant_eigvals</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">circulant_eigvects</span>
         <span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circulant_matrix</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_models</span><span class="p">()</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="BoxDataPM"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxDataPM">[docs]</a><span class="k">class</span> <span class="nc">BoxDataPM</span><span class="p">(</span><span class="n">BoxData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plus minus version of BoxData&quot;&quot;&quot;</span>
    <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">beta_plus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">beta_minus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tau_plus</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">tau_minus</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_beta</span><span class="p">):</span>
        <span class="c1"># -TODO -</span>
        <span class="c1"># consider removing the requirement of providing a delta_beta</span>
        <span class="c1"># could use a default value from constant module</span>
        <span class="c1"># with the ability to optionally override</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span> <span class="o">=</span> <span class="n">delta_beta</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">return</span>

<div class="viewcode-block" id="BoxDataPM.initialize_models"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxDataPM.initialize_models">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span> <span class="o">=</span> <span class="n">ModelVibronicPM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_vib_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">ModelSampling</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_rho_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxDataPM.preprocess"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxDataPM.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="c1"># compute extra constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_plus</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_minus</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">beads</span>

        <span class="c1"># do the usual work</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">preprocess</span><span class="p">()</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="BoxResult"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult">[docs]</a><span class="k">class</span> <span class="nc">BoxResult</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;use this to pass results back and forth between methods&quot;&quot;&quot;</span>

    <span class="n">id_job</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BoxResult.read_number_of_samples"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.read_number_of_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_number_of_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_full</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_full</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="BoxResult.verify_result_keys_are_present"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.verify_result_keys_are_present">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">verify_result_keys_are_present</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fileObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="n">key_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;number_of_samples, s_rho&quot;</span><span class="p">,</span> <span class="s2">&quot;s_g&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fileObj</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Expected key (</span><span class="si">{:s}</span><span class="s2">) not present in result file</span><span class="se">\n</span><span class="si">{:s}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">foramt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="BoxResult.initialize_arrays"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.initialize_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_name</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">pimc</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">beads</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">samples</span>
        <span class="k">elif</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">X</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The BoxResult object has been initialized with 0 samples this could be an issue?&quot;</span><span class="p">)</span>
            <span class="c1"># raise AssertionError(&quot;data or X must be provided to BoxResult __init__&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_arrays</span><span class="p">()</span>
        <span class="k">return</span>

<div class="viewcode-block" id="BoxResult.compute_path_to_file"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.compute_path_to_file">[docs]</a>    <span class="k">def</span> <span class="nf">compute_path_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; used by BoxResultPM as well &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2"> still has 0 samples - this should not happen&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_job</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_name</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id_job</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; TODO - this could be dangerous on the server if a BoxResult object is created</span>
<span class="sd">            but not assigned a job id - need to create a test to prevent this from happening</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># should be 0 or the last number + 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_name</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># search for other job id&#39;s</span>
                <span class="n">old_j</span> <span class="o">=</span> <span class="mi">90</span>  <span class="c1"># placeholder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_name</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="n">old_j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># result_view = slice(0, number_of_samples)</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path_root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="BoxResult.save_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.save_results">[docs]</a>    <span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_path_to_file</span><span class="p">()</span>

        <span class="c1"># save raw data points</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                 <span class="n">number_of_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                 <span class="n">s_rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span><span class="p">,</span>
                 <span class="n">s_g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span><span class="p">,</span>
                 <span class="c1"># s_g=self.scaled_g[result_view],</span>
                 <span class="c1"># s_rho=self.scaled_rho[result_view],</span>
                 <span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxResult.load_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.load_results">[docs]</a>    <span class="k">def</span> <span class="nf">load_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_full</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_full</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">BoxResult</span><span class="o">.</span><span class="n">verify_result_keys_are_present</span><span class="p">(</span><span class="n">path_full</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;BoxResult has a different number of samples that the input file - this should not happen&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_arrays</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_g&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_rho&quot;</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxResult.load_multiple_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResult.load_multiple_results">[docs]</a>    <span class="k">def</span> <span class="nf">load_multiple_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="n">number_of_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;list_of_paths cannot be empty&quot;</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">list_of_paths</span><span class="p">:</span>
            <span class="c1"># should verify path is correct?</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="c1"># should verify file is not empty?</span>
                <span class="n">number_of_samples</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">number_of_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number of samples should have changed&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">number_of_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_arrays</span><span class="p">()</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">list_of_paths</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">finish</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_g&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_rho&quot;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_rho&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">),</span> <span class="s2">&quot;Zeros in the denominator&quot;</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="BoxResultPM"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM">[docs]</a><span class="k">class</span> <span class="nc">BoxResultPM</span><span class="p">(</span><span class="n">BoxResult</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plus minus version of BoxResult&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BoxResultPM.verify_result_keys_are_present"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM.verify_result_keys_are_present">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">verify_result_keys_are_present</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fileObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">verify_result_keys_are_present</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fileObj</span><span class="p">)</span>
        <span class="n">key_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;s_gP&quot;</span><span class="p">,</span> <span class="s2">&quot;s_gM&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fileObj</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Expected key (</span><span class="si">{:s}</span><span class="s2">) not present in result file</span><span class="se">\n</span><span class="si">{:s}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">foramt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="BoxResultPM.initialize_arrays"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM.initialize_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize_arrays</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="BoxResultPM.save_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM.save_results">[docs]</a>    <span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_of_samples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_path_to_file</span><span class="p">()</span>

        <span class="c1"># save raw data points</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                 <span class="n">number_of_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                 <span class="n">s_rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span><span class="p">,</span>
                 <span class="n">s_g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span><span class="p">,</span>
                 <span class="n">s_gP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_plus</span><span class="p">,</span>
                 <span class="n">s_gM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_minus</span><span class="p">,</span>
                 <span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxResultPM.load_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM.load_results">[docs]</a>    <span class="k">def</span> <span class="nf">load_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_full</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_results</span><span class="p">(</span><span class="n">path_full</span><span class="p">)</span>
        <span class="c1"># this could be more efficient, since we open the file twice</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_full</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_plus</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_gP&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_minus</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_gM&quot;</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BoxResultPM.load_multiple_results"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.BoxResultPM.load_multiple_results">[docs]</a>    <span class="k">def</span> <span class="nf">load_multiple_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x&quot;&quot;&quot;</span>
        <span class="n">number_of_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;list_of_paths cannot be empty&quot;</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">list_of_paths</span><span class="p">:</span>
            <span class="c1"># should verify path is correct?</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="c1"># should verify file is not empty?</span>
                <span class="n">number_of_samples</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">number_of_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;number of samples should have changed&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">number_of_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_arrays</span><span class="p">()</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">list_of_paths</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">finish</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_g</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_g&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_rho</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_rho&quot;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_rho&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">),</span> <span class="s2">&quot;Zeros in the denominator&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_plus</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_gP&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scaled_gofr_minus</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;s_gM&quot;</span><span class="p">]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;number_of_samples&quot;</span><span class="p">]</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="pos_sym_assert"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.pos_sym_assert">[docs]</a><span class="k">def</span> <span class="nf">pos_sym_assert</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;raises error if provided tensor is not positive semi-definite&quot;&quot;&quot;</span>

    <span class="c1"># One method is to check if the matrix is positive semi definite within some tolerance</span>
    <span class="n">isPositiveSemiDefinite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">tensor</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">float_tolerance</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isPositiveSemiDefinite</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;The Covariance matrix is not symmetric positive-semidefinite&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># alternatively we can try to compute choleskys decomposition</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">choleskys</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;The Covariance matrix is not symmetric positive-semidefinite&quot;</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="scale_o_matricies"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.scale_o_matricies">[docs]</a><span class="k">def</span> <span class="nf">scale_o_matricies</span><span class="p">(</span><span class="n">scalingFactor</span><span class="p">,</span> <span class="n">model_one</span><span class="p">,</span> <span class="n">model_two</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;divides the O matricies of the models by the scalingFactor&quot;&quot;&quot;</span>
    <span class="n">model_one</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">/=</span> <span class="n">scalingFactor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="n">model_two</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">/=</span> <span class="n">scalingFactor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="un_scale_o_matricies"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.un_scale_o_matricies">[docs]</a><span class="k">def</span> <span class="nf">un_scale_o_matricies</span><span class="p">(</span><span class="n">scalingFactor</span><span class="p">,</span> <span class="n">model_one</span><span class="p">,</span> <span class="n">model_two</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;multiples the O matricies of the models by the scalingFactor&quot;&quot;&quot;</span>
    <span class="n">model_one</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">*=</span> <span class="n">scalingFactor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="n">model_two</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">*=</span> <span class="n">scalingFactor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="build_scaling_factors"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.build_scaling_factors">[docs]</a><span class="k">def</span> <span class="nf">build_scaling_factors</span><span class="p">(</span><span class="n">S12</span><span class="p">,</span> <span class="n">model_one</span><span class="p">,</span> <span class="n">model_two</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the individual and combined scaling factors for both provided models&quot;&quot;&quot;</span>
    <span class="c1"># compute the individual scaling factors</span>
    <span class="n">model_one</span><span class="o">.</span><span class="n">omatrix_scaling</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">model_one</span><span class="o">.</span><span class="n">omatrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">model_two</span><span class="o">.</span><span class="n">omatrix_scaling</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">model_two</span><span class="o">.</span><span class="n">omatrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># compute the combined scaling factor</span>
    <span class="n">S12</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">model_one</span><span class="o">.</span><span class="n">omatrix_scaling</span><span class="p">,</span> <span class="n">model_two</span><span class="o">.</span><span class="n">omatrix_scaling</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="build_o_matrix"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.build_o_matrix">[docs]</a><span class="k">def</span> <span class="nf">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the O matrix of a model, storing the result inside the model object&quot;&quot;&quot;</span>

    <span class="c1"># name and select the views</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">view</span><span class="p">(),</span> <span class="n">shift</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">coth</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cothBANP</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">csch</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cschBANP</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="c1"># compute the omatrix</span>
    <span class="n">o_matrix</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coth</span> <span class="o">*</span> <span class="p">(</span><span class="n">q1</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">q2</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.</span><span class="o">*</span><span class="n">csch</span><span class="o">*</span><span class="n">q1</span><span class="o">*</span><span class="n">q2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">o_matrix</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">o_matrix</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">omatrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">o_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">a</span><span class="p">]</span>

    <span class="n">temp_states</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">omatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># asserts that the tensor is diagonal along axis (2,3)</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">temp_states</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">temp_states</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">omatrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">))</span>

    <span class="c1"># this only works because omatrix is filled with zeros already</span>
    <span class="n">model</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">*=</span> <span class="n">model</span><span class="o">.</span><span class="n">omatrix_prefactor</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="build_denominator"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.build_denominator">[docs]</a><span class="k">def</span> <span class="nf">build_denominator</span><span class="p">(</span><span class="n">rho_model</span><span class="p">,</span> <span class="n">outputArray</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the state trace over the bead product of the o matricies of the rho model&quot;&quot;&quot;</span>
    <span class="c1"># outputArray[idx] = rho_model.omatrix.prod(axis=1).sum(axis=1)</span>
    <span class="n">outputArray</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_model</span><span class="o">.</span><span class="n">omatrix</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="diagonalize_coupling_matrix"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.diagonalize_coupling_matrix">[docs]</a><span class="k">def</span> <span class="nf">diagonalize_coupling_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># shift to surface independent co-ordinates</span>
    <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>

    <span class="c1"># build the coupling matrix</span>
    <span class="c1"># quadratic terms</span>
    <span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;acef, debc, abdf-&gt;afbc&#39;</span><span class="p">,</span>
                                        <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span><span class="p">,</span>
                                        <span class="mf">0.5</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">quadratic</span><span class="p">,</span>
                                        <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span><span class="p">,</span>
                                        <span class="c1"># optimize=&#39;optimal&#39;,  # not clear if this is faster</span>
                                        <span class="p">)</span>
    <span class="c1"># linear terms</span>
    <span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;dbc, abdf-&gt;afbc&#39;</span><span class="p">,</span>
                                      <span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span>
                                      <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span><span class="p">,</span>
                                      <span class="c1"># optimize=&#39;optimal&#39;,  # not clear if this is faster</span>
                                      <span class="p">)</span>
    <span class="c1"># reference hamiltonian (energy shifts)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">energy</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="c1"># shift back to surface dependent co-ordinates</span>
    <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">-=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="c1"># check that the coupling matrix is symmetric in surfaces</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span><span class="p">))</span>

    <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coupling_eigvals</span><span class="p">,</span>
     <span class="n">data</span><span class="o">.</span><span class="n">coupling_eigvects</span>
     <span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coupling_matrix</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="build_numerator"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.build_numerator">[docs]</a><span class="k">def</span> <span class="nf">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="p">,</span> <span class="n">outputArray</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the numerator and saves it to the outputArray&quot;&quot;&quot;</span>

    <span class="c1"># build the M matrix</span>
    <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abcd, abd, abed-&gt;abce&#39;</span><span class="p">,</span>
              <span class="n">data</span><span class="o">.</span><span class="n">coupling_eigvects</span><span class="p">,</span>
              <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">data</span><span class="o">.</span><span class="n">tau</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">coupling_eigvals</span><span class="p">),</span>
              <span class="n">data</span><span class="o">.</span><span class="n">coupling_eigvects</span><span class="p">,</span>
              <span class="n">out</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">M_matrix</span><span class="p">,</span>
              <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span>
              <span class="p">)</span>

    <span class="c1"># data.numerator = np.broadcast_to(   np.identity(data.states),</span>
    <span class="c1">#                                     data.size[&#39;BAA&#39;]</span>
    <span class="c1">#                                     )</span>

    <span class="c1"># reset numerator &#39;storage&#39; to be identity(in the AA dimension)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BAA&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">block_size</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">block_size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">beads</span><span class="p">):</span>
            <span class="c1"># this is correct</span>
            <span class="c1"># data.numerator[b, ...].dot(np.diagflat(vib.omatrix[b, p, :]))</span>
            <span class="c1"># this is twice as fast</span>
            <span class="c1"># data.numerator[b, ...].dot(np.diag(vib.omatrix[b, p, :]))</span>
            <span class="c1"># this is even faster</span>
            <span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vib</span><span class="o">.</span><span class="n">omatrix</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">out</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">M_matrix</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="c1"># trace over the surfaces</span>
    <span class="n">outputArray</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">outputArray</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;g(R) must always be positive&quot;</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="block_compute_gR"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.block_compute_gR">[docs]</a><span class="k">def</span> <span class="nf">block_compute_gR</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute and save only g(R) for building data_set to train ML algorithm</span>
<span class="sd">     for block_size # of sampled points in each loop&quot;&quot;&quot;</span>

    <span class="c1"># labels for clarity</span>
    <span class="n">vib</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span>

    <span class="c1"># store results here (these results are not! scaled)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_g</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>  <span class="c1"># should think about renaming scaled_g?</span>

    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">):</span>

        <span class="c1"># indicies</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">sample_view</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># generate sample points in collective co-ordinates</span>
        <span class="n">data</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># process the sapmled points</span>
        <span class="n">data</span><span class="o">.</span><span class="n">transform_sampled_coordinates</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># build O matricies for system distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>

        <span class="c1"># compute parts with normal scaling factor</span>
        <span class="n">diagonalize_coupling_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="save_gR_with_samples"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.save_gR_with_samples">[docs]</a><span class="k">def</span> <span class="nf">save_gR_with_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">input_R_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; temporary function to save g(R) results with R values</span>
<span class="sd">    don&#39;t want to pollute BoxResult with extra functions that might not be necessary in the future</span>
<span class="sd">    so this will go here for now&quot;&quot;&quot;</span>

    <span class="n">result</span><span class="o">.</span><span class="n">partial_name</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">training_data_g_output</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">beads</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute_path_to_file</span><span class="p">()</span>

    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
             <span class="n">number_of_samples</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
             <span class="n">g</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">scaled_g</span><span class="p">,</span>
             <span class="p">)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">partial_name</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">training_data_input</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">beads</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">temperature</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">compute_path_to_file</span><span class="p">()</span>

    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
             <span class="n">number_of_samples</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
             <span class="n">input_R_values</span><span class="o">=</span><span class="n">input_R_values</span><span class="p">,</span>
             <span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="block_compute_rhoR_from_input_samples"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.block_compute_rhoR_from_input_samples">[docs]</a><span class="k">def</span> <span class="nf">block_compute_rhoR_from_input_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">input_R_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute and save rho(R) from input R values for testing data_set to train ML algorithm</span>
<span class="sd">     for block_size # of sampled points in each loop</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># labels for clarity</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rho</span>

    <span class="c1"># views</span>
    <span class="n">rho_of_R</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_rho</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">input_R_view</span> <span class="o">=</span> <span class="n">input_R_values</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">):</span>

        <span class="c1"># indicies</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">sample_view</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># we copy in the data values that we read in from load_R_samples</span>
        <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">input_R_view</span><span class="p">[</span><span class="n">sample_view</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="c1"># we transform the dimensionless co-ordinates to surface dependent co-ordinates q = R - d</span>
        <span class="n">data</span><span class="o">.</span><span class="n">qTensor</span> <span class="o">-=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span><span class="o">.</span><span class="n">state_shift</span><span class="p">[</span><span class="n">NEW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">NEW</span><span class="p">]</span>

        <span class="c1"># build O matricies for system distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="n">build_denominator</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">rho_of_R</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

    <span class="c1"># return and let the caller of the function save the results appropriately</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="block_compute_gR_from_raw_samples"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.block_compute_gR_from_raw_samples">[docs]</a><span class="k">def</span> <span class="nf">block_compute_gR_from_raw_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Compute and save g(R) and R values for building data_set to train ML algorithm</span>
<span class="sd">     for block_size # of sampled points in each loop</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># labels for clarity</span>
    <span class="n">vib</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span>

    <span class="c1"># store results here (these results are not! scaled)</span>
    <span class="n">g_of_R</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_g</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>  <span class="c1"># should think about renaming scaled_g?</span>
    <span class="n">input_R_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;XNP&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">F64</span><span class="p">)</span>
    <span class="n">input_view</span> <span class="o">=</span> <span class="n">input_R_values</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">):</span>

        <span class="c1"># indicies</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">sample_view</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># generate sample points in surface dependent co-ordinates q = R - d</span>
        <span class="c1"># but which were not sampled from</span>
        <span class="n">data</span><span class="o">.</span><span class="n">generate_random_R_values</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">input_view</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># build O matricies for system distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>

        <span class="c1"># compute parts with normal scaling factor</span>
        <span class="n">diagonalize_coupling_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">g_of_R</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

    <span class="c1"># save results with their sampled co-ordinates</span>
    <span class="n">save_gR_with_samples</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">input_R_values</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="block_compute"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.block_compute">[docs]</a><span class="k">def</span> <span class="nf">block_compute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the numerator and denominator for block_size # of sampled points in each loop&quot;&quot;&quot;</span>

    <span class="c1"># block_index_list = [1e1, 1e2, 1e3, 1e4]</span>
    <span class="c1"># log.info(&quot;Block index list: &quot; + str(block_index_list))</span>

    <span class="c1"># labels for clarity</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rho</span>
    <span class="n">vib</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span>

    <span class="c1"># store results here</span>
    <span class="n">y_rho</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_rho</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">y_g</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_g</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="c1"># store the combined scaling factor in here</span>
    <span class="n">S12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BP&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">):</span>

        <span class="c1"># indicies</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">sample_view</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># generate sample points in collective co-ordinates</span>
        <span class="n">data</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># process the sapmled points</span>
        <span class="n">data</span><span class="o">.</span><span class="n">transform_sampled_coordinates</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># build O matricies for sampling distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="c1"># build O matricies for system distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>

        <span class="c1"># compute parts with normal scaling factor</span>
        <span class="n">build_scaling_factors</span><span class="p">(</span><span class="n">S12</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="n">scale_o_matricies</span><span class="p">(</span><span class="n">S12</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="n">build_denominator</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">y_rho</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>
        <span class="n">diagonalize_coupling_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">y_g</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># # periodically save results to file</span>
        <span class="c1"># if (block_index + 1) in block_index_list:</span>
        <span class="c1">#     s = &quot;Block index: {:d}\nNumber of samples: {:d}&quot;</span>
        <span class="c1">#     log.info(s.format(block_index + 1, end))</span>
        <span class="c1">#     result.save_results(end)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="block_compute_pm"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.block_compute_pm">[docs]</a><span class="k">def</span> <span class="nf">block_compute_pm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BoxDataPM</span><span class="p">),</span> <span class="s2">&quot;incorrect object type&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">BoxResultPM</span><span class="p">),</span> <span class="s2">&quot;incorrect object type&quot;</span>

    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># for blockIdx, block in enumerate(range(0, block_size*blocks, block_size)):</span>
    <span class="c1"># block_index_list = [1e1, 1e2, 1e3, 1e4, 2e4, 3e4, 4e4, 5e4, 6e4, 7e4, 8e4, 9e4, 1e5]</span>
    <span class="c1"># log.info(&quot;Block index list: &quot; + str(block_index_list))</span>

    <span class="c1"># labels for clarity</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rho</span>
    <span class="n">vib</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vib</span>

    <span class="c1"># store results here</span>
    <span class="n">y_rho</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_rho</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="n">y_g</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_g</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">y_gp</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_gofr_plus</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="n">y_gm</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">scaled_gofr_minus</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

    <span class="c1"># store the combined scaling factor in here</span>
    <span class="n">S12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="s1">&#39;BP&#39;</span><span class="p">])</span>
    <span class="c1"># startTime = time.process_time()</span>
    <span class="c1"># log.info(&quot;Start: {:f}&quot;.format(startTime))</span>
    <span class="k">for</span> <span class="n">block_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">blocks</span><span class="p">):</span>

        <span class="c1"># indicies</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">block_index</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">block_size</span>
        <span class="n">sample_view</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># generate sample points in collective co-ordinates</span>
        <span class="n">data</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># process the sapmled points</span>
        <span class="n">data</span><span class="o">.</span><span class="n">transform_sampled_coordinates</span><span class="p">(</span><span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># build O matricies for sampling distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="c1"># build O matricies for system distribution</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>

        <span class="c1"># compute parts with normal scaling factor</span>
        <span class="n">build_scaling_factors</span><span class="p">(</span><span class="n">S12</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="n">scale_o_matricies</span><span class="p">(</span><span class="n">S12</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
        <span class="n">build_denominator</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">y_rho</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>
        <span class="n">diagonalize_coupling_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="n">y_g</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># Plus</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const_plus</span><span class="p">)</span>
        <span class="n">vib</span><span class="o">.</span><span class="n">const_plus</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">/=</span> <span class="n">S12</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const_plus</span><span class="p">,</span> <span class="n">y_gp</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># Minus</span>
        <span class="n">build_o_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const_minus</span><span class="p">)</span>
        <span class="n">vib</span><span class="o">.</span><span class="n">const_minus</span><span class="o">.</span><span class="n">omatrix</span> <span class="o">/=</span> <span class="n">S12</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NEW</span><span class="p">,</span> <span class="n">NEW</span><span class="p">]</span>
        <span class="n">build_numerator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vib</span><span class="o">.</span><span class="n">const_minus</span><span class="p">,</span> <span class="n">y_gm</span><span class="p">,</span> <span class="n">sample_view</span><span class="p">)</span>

        <span class="c1"># periodically save results to file</span>
        <span class="c1"># if (block_index + 1) in block_index_list:</span>
        <span class="c1">#     curTime = time.process_time()</span>
        <span class="c1">#     timeElapsed = curTime - startTime</span>
        <span class="c1">#     startTime = curTime</span>
        <span class="c1">#     log.info(&quot;Time elapsed: {:f}&quot;.format(timeElapsed))</span>
        <span class="c1">#     s = &quot;Block index: {:d}\nNumber of samples: {:d}&quot;</span>
        <span class="c1">#     log.info(s.format(block_index + 1, end))</span>
        <span class="c1">#     result.save_results(end)</span>

    <span class="n">result</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="simple_wrapper"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.simple_wrapper">[docs]</a><span class="k">def</span> <span class="nf">simple_wrapper</span><span class="p">(</span><span class="n">id_data</span><span class="p">,</span> <span class="n">id_rho</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Just do simple expval(Z) calculation&quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">232942</span><span class="p">)</span>  <span class="c1"># pick our seed</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="p">)</span>
    <span class="n">Bsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="p">)</span>

    <span class="c1"># load the relevant data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">BoxData</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">id_data</span> <span class="o">=</span> <span class="n">id_data</span>
    <span class="n">data</span><span class="o">.</span><span class="n">id_rho</span> <span class="o">=</span> <span class="n">id_rho</span>

    <span class="n">files</span> <span class="o">=</span> <span class="n">file_structure</span><span class="o">.</span><span class="n">FileStructure</span><span class="p">(</span><span class="s1">&#39;/work/ngraymon/pimc/&#39;</span><span class="p">,</span> <span class="n">id_data</span><span class="p">,</span> <span class="n">id_rho</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">path_vib_model</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_vib_model</span>
    <span class="n">data</span><span class="o">.</span><span class="n">path_rho_model</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_rho_model</span>

    <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">data</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">data</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="n">data</span><span class="o">.</span><span class="n">beads</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">data</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">300.0</span>
    <span class="n">data</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">//</span> <span class="n">Bsize</span>
    <span class="n">data</span><span class="o">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">Bsize</span>

    <span class="c1"># setup empty tensors, models, and constants</span>
    <span class="n">data</span><span class="o">.</span><span class="n">preprocess</span><span class="p">()</span>

    <span class="c1"># store results here</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">BoxResult</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">path_root</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_rho_results</span>

    <span class="n">block_compute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="plus_minus_wrapper"><a class="viewcode-back" href="../../../pibronic.pimc.html#pibronic.pimc.minimal.plus_minus_wrapper">[docs]</a><span class="k">def</span> <span class="nf">plus_minus_wrapper</span><span class="p">(</span><span class="n">id_data</span><span class="p">,</span> <span class="n">id_rho</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate all the possible temp +/- approaches&quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">232942</span><span class="p">)</span>  <span class="c1"># pick our seed</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="p">)</span>
    <span class="n">Bsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="p">)</span>

    <span class="n">delta_beta</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">delta_beta</span>

    <span class="c1"># load the relevant data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">BoxDataPM</span><span class="p">(</span><span class="n">delta_beta</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">id_data</span> <span class="o">=</span> <span class="n">id_data</span>
    <span class="c1"># data.id_rho = 0</span>

    <span class="n">files</span> <span class="o">=</span> <span class="n">file_structure</span><span class="o">.</span><span class="n">FileStructure</span><span class="p">(</span><span class="s1">&#39;/work/ngraymon/pimc/&#39;</span><span class="p">,</span> <span class="n">id_data</span><span class="p">,</span> <span class="n">id_rho</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">path_vib_model</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_vib_model</span>
    <span class="n">data</span><span class="o">.</span><span class="n">path_rho_model</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_rho_model</span>

    <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">data</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">data</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="n">data</span><span class="o">.</span><span class="n">beads</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">data</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">300.00</span>
    <span class="n">data</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">//</span> <span class="n">Bsize</span>
    <span class="n">data</span><span class="o">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">Bsize</span>

    <span class="c1"># setup empty tensors, models, and constants</span>
    <span class="n">data</span><span class="o">.</span><span class="n">preprocess</span><span class="p">()</span>

    <span class="c1"># store results here</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">BoxResultPM</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">path_root</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">path_rho_results</span>

    <span class="c1"># block_compute(data, results)</span>
    <span class="n">block_compute_pm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
    <span class="k">return</span></div>


<span class="k">if</span> <span class="p">(</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Neil Raymond.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>